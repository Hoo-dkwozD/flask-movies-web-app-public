# A simple web app using the Flask microframework that serves information on any
# show the user searches for through IMDB's API
# ==============================================================================

### Import necessary packages
from flask import Flask, render_template, url_for, redirect, request, session
from werkzeug.security import generate_password_hash, check_password_hash
import requests

### parse_ini_file() function to parse INI files for password and config related
### information
def parse_ini_file(filename: str) -> dict:
    """
    Used to parse ini files, which are usually used to store senstive information
    Returns a dictionary

    Argument(s):
        filename -> A string containing the path to the INI file
    
    Raises:
        OSError -> File not found in the filepath specified
        ValueError -> A line in the INI file does not contain a separating `:`
        TypeError -> The filename is not a string that ends with `.ini`

    Returns:
        result (dict) -> A dictionary with the INI file being parsed into key-value pairs
    """

    if isinstance(filename, str) and filename.endswith(".ini"): 
        # Ensures filename is a str and ends with '.ini'

        result = dict()

        with open(filename) as ini_file: # Default use of 'rt' for open()
            for line in ini_file: # Reads line by line of the INI file
                line = line.strip() # Removes trailings

                # Ignores INI file comments
                if line.startswith(";"): 
                    continue

                # Breaks line into key-value pairs
                try:
                    separator = line.index(":")
                except: # If `:` not found
                    ValueError(f"The following line contains no `:` :\n\t{line}")
                line_arr = [] # Array collection of key-value pair
                line_arr.append(line[:separator]) # Key
                line_arr.append(line[separator + 1:]) # Value

                # Stores into the result dictionary
                result[line_arr[0].strip()] = line_arr[1].strip()
        
        return result
    else:
        raise TypeError("The argument `filename` is not a string ending in `.ini`")

### Instantiation of the web app
app = Flask(__name__) # App has import_name "__main__"
app.config["DEBUG"] = True # Helps with debugging

# Parse the INI files
ini_files = parse_ini_file("./priv/app.ini") # INI file is in the priv folder
app.secret_key = ini_files["secret_key"] # Get secret key
hashed_pass = ini_files["password"] 
# Get password that is generated by generate_password_hash() beforehand
# e.g. hashed_pass = generate_password_hash(password) 
api_key = ini_files["api_key"] # Get API key
LIMIT = 4 # Limit API usage to 4 times per login

### Start of URL routing
@app.route("/")
def landing_page():
    # First page user encounters
    try: 
        return render_template("landing-page.html") 
        # Form in landing-page.html submits to search_results() via POST
    except:
        return render_template("error404.html")
    finally:
        # Logs out if LIMIT is reached
        if "load_log" in session and session["load_log"] >= LIMIT:
            session.pop("is_logged", None)
            session.pop("load_log", None)
        # Clears current stored query
        if "query_log" in session:
            session.pop("query_log", None)

@app.route("/search", methods=["POST"])
def search_result():
    # Form processing and flow control intermediary page
    try:
        # Get form input
        user_query = request.form["search_query"]
        
        if "is_logged" in session: # If the user is logged in
            redirect_url = url_for(".search", query_string=user_query)
            return redirect(redirect_url) 
        else: # If the user is not logged in
            # Store query temporarily
            session["query_log"] = user_query 
            # Redirect to login page
            redirect_url = url_for(".login") 
            return redirect(redirect_url)
    except:
        return render_template("error404.html")
    finally: 
        # Logs out if LIMIT is reached
        if "load_log" in session and session["load_log"] >= LIMIT:
            session.pop("is_logged", None)
            session.pop("load_log", None)

@app.route("/login")
def login():
    # Login page for user
    try:
        # Check for errors encountered when logging in just before current attempt
        if "errors" in session:
            pwd_text = "Wrong password! Please re-type password."
            session.pop("errors", None) # Clears prior errors from session
        else:
            pwd_text = "Please type in password."
        # Renders login page with different header messages
        return render_template("login.html", pwd_text = pwd_text)
        # login.html submits a form to logged() via POST method
    except:
        return render_template("error404.html")
    finally:
        # Logs out if LIMIT is reached
        if "load_log" in session and session["load_log"] >= LIMIT:
            session.pop("is_logged", None)
            session.pop("load_log", None)

@app.route("/logged", methods=["POST"])
def logged():
    # Login form processing intermediary page
    try:
        # Retrieve password from form
        user_pass = request.form["user_password"]
        # Password verification
        if check_password_hash(hashed_pass, user_pass): # Check hashed password
            session["is_logged"] = True
            session["load_log"] = 0

            if "query_log" in session: 
                # If a pending query exists
                user_query = session["query_log"]
                session.pop("query_log", None) # Clear pending query

                redirect_url = url_for(".search", query_string=user_query)
                return redirect(redirect_url)
            else:
                # User has no pending queries
                redirect_url = url_for(".landing_page")
                return redirect(redirect_url)
        else: # Wrong password
            if "is_logged" in session: # Logs out immediately
                session.pop("is_logged", None)
                session.pop("load_log", None) 
            # Marks an error logging in 
            session["errors"] = True
            # Redirects back to login page
            redirect_url = url_for(".login")
            return redirect(redirect_url)
    except:
        # Clears current stored query
        if "query_log" in session:
            session.pop("query_log", None)
        
        return render_template("error404.html")

@app.route("/search/<query_string>") # methods=["GET"]
def search(query_string):
    # Main page that displays search result
    if "is_logged" not in session: # User not logged in
        session["query_log"] = query_string # Stores query temporarily
        # Redirect to login page
        redirect_url = url_for(".login")
        return redirect(redirect_url)
    # API source
    url = "https://imdb8.p.rapidapi.com/title/auto-complete"
    # Query
    querystring = {"q":query_string}
    # Headers
    headers = {
        'x-rapidapi-key': api_key,
        'x-rapidapi-host': "imdb8.p.rapidapi.com"
        }
    # Call API
    try:
        response = requests.request("GET", url, headers=headers, params=querystring)
        data = response.json() # JSON response from API
        return render_template("search-result.html", data=data)
    except:
        return render_template("error404.html")
    finally:
        # Clears current stored entry
        if "query_log" in session:
            session.pop("query_log", None)
        # Update the load_log variable
        session["load_log"] += 1
        # Logs out if LIMIT is reached
        if session["load_log"] >= LIMIT:
            session.pop("is_logged", None)
            session.pop("load_log", None)

### Run app 
if __name__=="__main__":
    app.run(host="0.0.0.0", port="5000")